/*
  NOTE: 
      - Change the truffle_config.js file inside 
      "C:\Users\ADMIN\AppData\Roaming\npm\node_modules\truffle\build\initSource (windows)"
      to uncomment the ntewrok.development in truffle_config file generated by "truffle init" command

      Docker Specific: 
        - Create a "truffle_config" file and copy that to the 
        Global installation via npm:
             - This: /usr/local/lib/node_modules/truffle/init/truffle-init.default.js
             - Or : /usr/lib/node_modules/truffle/init/truffle-init.default.js


             ----------------------- Backend For a MVP Version of Solidity Playground is Ready -------------------------------
      Architecture: 
        Containers: 
          - Ganache (Local Ethereum Virtual Machine)
                            ^
                            |
          - Node Dependencies and Truffle (Depends on Ganache Service)
                            ^
                            |
          - Nginx
      
      Kubernetes Specific: 
          Architecture:
            Pod (With Multi Container):
                - Ganache (Local Ethereum Virtual Machine) (Dependent Container)
                               ^
                               |
                - Node Dependencies and Truffle (Depends on Ganache Service)
                      


*/

const express = require('express');
const nanoid = require('nanoid');
const fs = require('fs').promises;
const path = require('path');
const { promisify } = require('util');
const { execSync } = require('child_process');
const app = express();

app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// Read Directory or file
const readDirAsync = promisify(fs.readdir);
const readStatAsync = promisify(fs.stat);
const readFileAsync = promisify(fs.readFile);

// Write file
const writeFileAsync = promisify(fs.writeFile);

// Make Directory
const mkDirAsync = promisify(fs.mkdir);

// Isolated Container for each request
const requestMap = new Map();

//  initialize Solidity Playground
const initializeSolidityPlayground = async (directoryPath) => {
  const contract = `// SPDX-License-Identifier: MIT
  pragma solidity >=0.4.22 <0.9.0;

  contract HelloWorld {
  
    string public message = "Hello, World!";
  
    function sayHello() public view returns (string) {
      return message;
    }
  
  }
  `;

  const migrationScript = `var HelloWorld = artifacts.require("HelloWorld");

  module.exports = function(deployer) {
    deployer.deploy(HelloWorld);
  };
  `;

  /* 

    Contract: /contract/HelloWorld.sol
    MigrationScript: /migrations/1_deploy_hello_world.js

  */

  await writeFileAsync(`${directoryPath}\\contracts\\HelloWorld.sol`, contract);
  await writeFileAsync(
    `${directoryPath}\\migrations\\1_deploy_hello_world.js`,
    migrationScript
  );
};

/*
  Recreate the directory structure from the directory tree.
     - This ensures that the directory structure is consistent with the
       directory tree, which makes it easier to navigate and manage the code.

*/

const replicateDirectorySetup = async (directoryTree, currentPath) => {
  try {
    const absoluteCurrentPath = path.join(`${process.cwd()}`, `${currentPath}`);

    if (directoryTree.type === 'directory') {
      await mkDirAsync(absoluteCurrentPath, { recursive: true });

      if (Array.isArray(directoryTree.children)) {
        for (const subdirectory of directoryTree.children) {
          await replicateDirectorySetup(
            subdirectory,
            path.join(currentPath, subdirectory.name)
          );
        }
      }
    } else if (directoryTree.type === 'file') {
      await writeFileAsync(absoluteCurrentPath, directoryTree.content || '');
    }
  } catch (error) {
    console.log('error: ', error);
  }
};

// Create a directory tree
const generateDirectoryStructureWithFiles = async (directoryPath, isRoot) => {
  const directoryContents = await readDirAsync(directoryPath, {
    withFileTypes: true,
    recursive: true,
  });

  const directoryTree = {
    name: path.basename(directoryPath),
    type: 'directory',
    children: [],
  };

  //  Base condition
  if (isRoot) {
    directoryTree['root'] = path.join(
      path.basename(path.dirname(directoryPath)),
      'sol'
    );
  }

  // Iterate over the directory
  for (const item of directoryContents) {
    // Donot track node modules folder
    if (item === 'node_modules') {
      continue;
    }
    const itemPath = path.join(directoryPath, item.name);
    const itemStats = await readStatAsync(itemPath);
    // If the item is a subdirectory then recursively to the tree
    if (itemStats.isDirectory()) {
      const subdirectoryTree = await generateDirectoryStructureWithFiles(
        itemPath,
        false
      );
      directoryTree.children.push(subdirectoryTree);
    } else {
      const fileContent = await readFileAsync(itemPath, 'utf-8');
      const fileNode = {
        name: item.name,
        type: 'file',
        content: fileContent,
      };
      directoryTree.children.push(fileNode);
    }
  }
  return directoryTree;
};

// Route to initialize truffle project
app.get('/initialize', (req, res) => {
  try {
    // Generates a Unique String per request
    const nanoidNumeric = nanoid.customAlphabet('1234567890abcdef', 10);
    const containerId = nanoidNumeric();

    // Handle Collison
    if (requestMap.has(containerId)) {
      while (requestMap.has(containerId)) {
        containerId = nanoidNumeric();
      }
    }
    requestMap.set(containerId, containerId);
    const directoryPath = `${process.cwd()}\\${containerId}\\Sol`;
    if (!fs.existsSync(directoryPath)) {
      console.log('Not found');
      fs.mkdir(directoryPath, { recursive: true }, async (err) => {
        if (err) {
          console.log(err);
          console.log(`Cannot Create ${directoryPath}`);
          res.json({
            status: 'error',
            message: `Cannot Create ${directoryPath}`,
          });
        } else {
          execSync(`cd ${directoryPath} && truffle init`);
          await initializeSolidityPlayground(directoryPath);
          res.json({
            status: 'Success',
            message: 'Truffle Project Initialized Successfully',
            data: await generateDirectoryStructureWithFiles(
              directoryPath,
              true
            ),
          });
        }
      });
    }
  } catch (error) {
    res.json({ status: 'error', message: error });
  }
});

// Route to compile the smart contract
app.post('/compileContract', async (req, res) => {
  try {
    // Replicate the Frontend directory structure
    await replicateDirectorySetup(req.body, req.body.root, '');

    // Constructs the directory structure assigned for the request.
    const projectDirectory = `${process.cwd()}\\${req.body.root}`;

    // Compiles the smart contract and gets the compilation results.
    const compilationResult = execSync(
      `cd ${projectDirectory} && truffle compile`
    ).toString();

    // Gets the directory tree after compilation.
    res.json({
      status: 'success',
      message: compilationResult,
      data: await generateDirectoryStructureWithFiles(projectDirectory, true),
    });
  } catch (error) {
    console.log('error', error);
    res.json({
      status: 'error',
      message: 'Compilation failed...',
    });
  }
});

// Route deploy or migrate the smart contract to the local Ethereum Virtual Machine.
app.post('/migrate', (req, res) => {
  try {
    const { root } = req.body;
    const directoryPath = path.join(process.cwd().toString(), root, 'sol');

    const deployResponse = execSync(
      `cd ${directoryPath} && truffle migrate`
    ).toString('utf-8');

    res.json({
      status: 'success',
      message: 'Contract Deployed Successfully',
      data: Buffer.from(deployResponse, 'utf-8').toString(),
    });
  } catch (error) {
    console.log('error: ', error);
    res.json({
      status: 'error',
      message: 'Deployment failed...',
      error: error.message,
    });
  }
});

// Route to clear the directory assigned to a candidate for Solidity during the interview
app.post('/clearCandidateDirectory', async (req, res) => {
  const { root } = req.body;
  const directoryPath = path.join(process.cwd().toString(), root);
  try {
    await fs.rmdir(directoryPath, { recursive: true, force: true });
    res.json({ status: 'success', message: 'Removed...' });
  } catch (error) {
    console.log('error: ', error.message);
    res.json({ status: 'error', message: `${error.message}` });
  }
});

app.listen('10000', () => {
  console.log('Etherium Server Listening at port 10000');
});
